Data Validation on Far Locations in the Data Graph Using Shape Names
Problem:

SHACL currently operates based on node shapes applied directly to target nodes or paths. Validating "far locations" (nodes not directly connected or deeply nested) requires referencing shapes across multiple levels of the graph.
Proposed Solution:

    Introduce farLocationTarget or referenceShapeTarget:
        Define a mechanism to use shape names to validate nodes at distant locations.
        Leverage sh:targetShape combined with a new sh:referencePath.

Example:

:FarLocationShape
    a sh:NodeShape ;
    sh:referencePath [ sh:inversePath ex:relatedTo ] ;
    sh:targetShape :SomeOtherShape ;
    sh:property [
        sh:path ex:property ;
        sh:datatype xsd:string ;
    ] .

Here:

    sh:referencePath specifies how to navigate the graph.
    sh:targetShape ensures nodes matching a distant shape are used for validation.



2. Data Creation
Problem:

SHACL is focused on validation but doesn't provide mechanisms for modifying or creating data.
Proposed Solution:

    Introduce a sh:create property:
        Specifies default values or templates for missing data during validation.

Example:

:CreationShape
    a sh:NodeShape ;
    sh:property [
        sh:path ex:newProperty ;
        sh:create "defaultValue" ;
    ] .

Behavior:

    During validation, SHACL engines create ex:newProperty with defaultValue if it doesn’t exist.

3. Data Creation Using Far Locations
Problem:

Creation of new data based on distant or deeply nested nodes isn’t straightforward in SHACL.
Proposed Solution:

    Extend sh:create to support paths that traverse far locations.

Example:

:FarLocationCreationShape
    a sh:NodeShape ;
    sh:create [
        sh:path [ sh:inversePath ex:relatedTo ] ;
        sh:value "autoGeneratedValue" ;
    ] .

Here:

    The sh:create block uses a path to indicate where the new data should be added.

4. Input and Output Function Calls and Mapping Outputs to a Data Path
Problem:

SHACL lacks built-in mechanisms to handle input/output functions and map the results to a graph.
Proposed Solution:

    Introduce:
        sh:inputFunction: Specifies a function with required parameters.
        sh:outputMapping: Maps the function's output to a path.

Example:

:FunctionShape
    a sh:NodeShape ;
    sh:inputFunction [
        sh:functionName "computeValue" ;
        sh:parameters [
            sh:path ex:inputProperty ;
        ] ;
    ] ;
    sh:outputMapping [
        sh:path ex:outputProperty ;
        sh:datatype xsd:string ;
    ] .

Behavior:

    The SHACL engine calls the computeValue function, passing values from ex:inputProperty.
    The function's result is mapped to ex:outputProperty.

1. Creation Semantics in SHACL Advanced

Creation semantics in SHACL-AF focus on generating new data during the validation process or rule execution. These semantics are closely tied to SHACL rules and can also involve generating default values, derived triples, or inferred data.
Key Components:

    Rule-Based Creation:
        SHACL-AF introduces the sh:rule property, allowing the specification of rules that create new triples based on existing data.

    Default Values:
        Properties like sh:defaultValue can provide default values for properties that are missing in the data graph.

    Target-Based Creation:
        Data creation can be scoped to nodes or graphs using SHACL's targeting mechanisms (sh:targetClass, sh:targetNode, etc.).

Example:

:PersonShape
    a sh:NodeShape ;
    sh:targetClass ex:Person ;
    sh:property [
        sh:path ex:birthplace ;
        sh:defaultValue ex:UnknownLocation ;
    ] .

Semantics:

    If a node conforms to ex:Person but does not have ex:birthplace, the SHACL processor generates a triple associating it with ex:UnknownLocation.

2. Rules in SHACL Advanced

Rules in SHACL-AF define logical or procedural transformations applied to the data graph. These rules can:

    Derive new data.
    Add inferred triples.
    Transform data for reasoning purposes.

Rule Types:

    Triple Rules (sh:TripleRule):
        Used to generate new triples directly.

    Node Rules (sh:NodeRule):
        Used to create or modify nodes or node properties.

    SPARQL-Based Rules:
        Allow custom SPARQL queries to drive data creation or inference.

Key Rule Properties:

    sh:rule: Attaches rules to a shape.
    sh:condition: Specifies preconditions for applying the rule.
    sh:construct: (for SPARQL rules) Contains a SPARQL CONSTRUCT query for generating triples.

Example of a Triple Rule:

:PersonShape
    a sh:NodeShape ;
    sh:targetClass ex:Person ;
    sh:rule [
        a sh:TripleRule ;
        sh:subject sh:this ;
        sh:predicate ex:hasAgeCategory ;
        sh:object ex:Adult ;
        sh:condition [
            sh:property [
                sh:path ex:age ;
                sh:minInclusive 18 ;
            ] ;
        ] ;
    ] .

Semantics:

    For every node conforming to :PersonShape, if ex:age is at least 18, the triple (node, ex:hasAgeCategory, ex:Adult) is added to the graph.

3. Rule Semantics

SHACL-AF defines the operational semantics for rules, including when and how they are applied. These semantics are designed to be consistent with RDF and SPARQL processing.
Evaluation Steps:

    Target Identification:
        Determine the nodes to which a shape (and its rules) apply using SHACL’s targeting mechanisms.

    Condition Checking:
        Validate conditions (sh:condition) before applying rules.

    Rule Execution:
        For sh:TripleRule, generate triples directly.
        For sh:NodeRule, modify node properties or create new nodes.
        For SPARQL rules, execute the sh:construct query and merge the results into the graph.

    Iteration:
        Rules can be applied iteratively to allow cascading effects (e.g., inferred data triggering additional rules).

4. Combining Creation Semantics and Rules

SHACL-AF allows combining creation semantics and rules to achieve sophisticated workflows, such as:

    Filling in missing data with defaults (sh:defaultValue).
    Inferring new classifications (sh:rule).
    Constructing entirely new subgraphs based on existing data.

Complex Example:

:EmployeeShape
    a sh:NodeShape ;
    sh:targetClass ex:Employee ;
    sh:property [
        sh:path ex:department ;
        sh:defaultValue ex:GeneralDepartment ;
    ] ;
    sh:rule [
        a sh:TripleRule ;
        sh:subject sh:this ;
        sh:predicate ex:hasRole ;
        sh:object ex:Staff ;
    ] ;
    sh:rule [
        a sh:TripleRule ;
        sh:subject sh:this ;
        sh:predicate ex:reportsTo ;
        sh:object ex:DefaultManager ;
    ] .

Semantics:

    For every node matching ex:Employee:
        Add ex:department with the default value ex:GeneralDepartment (if missing).
        Generate triples (node, ex:hasRole, ex:Staff) and (node, ex:reportsTo, ex:DefaultManager).

5. SHACL-AF Execution Models

The execution of SHACL-AF rules and creation semantics depends on the chosen processing model:

    Batch Mode:
        Apply all rules and creation semantics after an initial validation pass.
    Incremental Mode:
        Apply rules iteratively as new data is inferred or created.
    Dynamic Mode:
        Integrate with real-time systems to apply rules and creation semantics as data changes.

